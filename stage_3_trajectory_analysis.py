# -*- coding: utf-8 -*-
"""stage_3 trajectory analysis

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oYcGt1czWrGADguAEFqJYKAHikJJuTn8
"""

!pip install scanpy
!pip install anndata
!pip3 install igraph
!pip install celltypist
!pip install decoupler
!pip install fa2-modified
!pip install louvain
!pip install scvelo

#Import core single cell datasets

import scanpy as sc
import anndata as ad
import numpy as np
#import scvelo as scv

!mkdir -p GSM5082289

!wget https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM5082nnn/GSM5082289/suppl/GSM5082289%5Fmock%5Fbarcodes.tsv.gz -O GSM5082289/barcodes.tsv.gz
!wget https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM5082nnn/GSM5082289/suppl/GSM5082289%5Fmock%5Ffeatures.tsv.gz -O GSM5082289/features.tsv.gz
!wget https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM5082nnn/GSM5082289/suppl/GSM5082289%5Fmock%5Fmatrix.mtx.gz -O GSM5082289/matrix.mtx.gz

!mkdir -p GSM5082290

!wget https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM5082nnn/GSM5082290/suppl/GSM5082290%5F1dpi%5Fbarcodes.tsv.gz -O GSM5082290/barcodes.tsv.gz
!wget https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM5082nnn/GSM5082290/suppl/GSM5082290%5F1dpi%5Ffeatures.tsv.gz -O GSM5082290/features.tsv.gz
!wget https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM5082nnn/GSM5082290/suppl/GSM5082290%5F1dpi%5Fmatrix.mtx.gz -O GSM5082290/matrix.mtx.gz

!mkdir -p GSM5082291

!wget https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM5082nnn/GSM5082291/suppl/GSM5082291%5F2dpi%5Fbarcodes.tsv.gz -O GSM5082291/barcodes.tsv.gz
!wget https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM5082nnn/GSM5082291/suppl/GSM5082291%5F2dpi%5Ffeatures.tsv.gz -O GSM5082291/features.tsv.gz
!wget https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM5082nnn/GSM5082291/suppl/GSM5082291%5F2dpi%5Fmatrix.mtx.gz -O GSM5082291/matrix.mtx.gz

!mkdir -p GSM5082292

!wget https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM5082nnn/GSM5082292/suppl/GSM5082292%5F3dpi%5Fbarcodes.tsv.gz -O GSM5082292/barcodes.tsv.gz
!wget https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM5082nnn/GSM5082292/suppl/GSM5082292%5F3dpi%5Ffeatures.tsv.gz -O GSM5082292/features.tsv.gz
!wget https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM5082nnn/GSM5082292/suppl/GSM5082292%5F3dpi%5Fmatrix.mtx.gz -O GSM5082292/matrix.mtx.gz

adata_mock = sc.read_10x_mtx('/content/GSM5082289/')
adata_1dpi = sc.read_10x_mtx('/content/GSM5082290/')
adata_2dpi = sc.read_10x_mtx('/content/GSM5082291/')
adata_3dpi = sc.read_10x_mtx('/content/GSM5082292/')

print(adata_mock)
print(adata_1dpi)
print(adata_2dpi)
print(adata_3dpi)

adata_mock.shape
adata_1dpi.shape
adata_2dpi.shape
adata_3dpi.shape

# let's look at the first 5 rows describing the genes in our dataset
adata_mock.var.head()
adata_1dpi.var.head()
adata_2dpi.var.head()
adata_3dpi.var.head()

# let's look at the first 5 rows describing the cells (ID) in our dataset
adata_mock.obs.head()

adata_1dpi.obs.head()

adata_2dpi.obs.head()

adata_3dpi.obs.head()

# How about both. in a proper dataframe format

adata_mock.to_df()

adata_1dpi.to_df()

adata_2dpi.to_df()

adata_3dpi.to_df()

# A useful step for older datasets
adata_mock.var_names_make_unique()
adata_mock.obs_names_make_unique()

# A useful step for older datasets
adata_1dpi.var_names_make_unique()
adata_1dpi.obs_names_make_unique()

# A useful step for older datasets
adata_2dpi.var_names_make_unique()
adata_2dpi.obs_names_make_unique()

# A useful step for older datasets
adata_3dpi.var_names_make_unique()
adata_3dpi.obs_names_make_unique()

# Let's search for possible contamination from dying cells, ribosomal transcripts or hemoglobin

# Cells with a high proportion of mitochondrial reads (say >10â€“20%) are likely stressed, apoptotic, or poorly captured
# Ribosomal transcripts are removed because they represent global transcriptional activity, not cell-type-specific biology
# Instead of true cell populations, high HB signal often represents ambient RNA contamination from lysed red blood cells

adata_mock.var['MT'] = adata_mock.var_names.str.startswith("MT-")
adata_mock.var['RIBO'] = adata_mock.var_names.str.startswith(("RPS", "RPL"))
adata_mock.var['HB'] = adata_mock.var_names.str.startswith("HB-")

adata_1dpi.var['MT'] = adata_1dpi.var_names.str.startswith("MT-")
adata_1dpi.var['RIBO'] = adata_1dpi.var_names.str.startswith("RPS", "RPL")
adata_1dpi.var['HB'] = adata_1dpi.var_names.str.startswith("^HB[^(P)]")

adata_2dpi.var['MT'] = adata_2dpi.var_names.str.startswith("MT-")
adata_2dpi.var['RIBO'] = adata_2dpi.var_names.str.startswith("RPS", "RPL")
adata_2dpi.var['HB'] = adata_2dpi.var_names.str.startswith("^HB[^(P)]")

adata_3dpi.var['MT'] = adata_3dpi.var_names.str.startswith("MT-")
adata_3dpi.var['RIBO'] = adata_3dpi.var_names.str.startswith("RPS", "RPL")
adata_3dpi.var['HB'] = adata_3dpi.var_names.str.startswith("^HB[^(P)]")

#let's just take a quick look at one of them.

mt_genes = adata_mock.var[adata_mock.var['MT']]
mt_genes

#let's just take a quick look at one of them.

mt_genes = adata_1dpi.var[adata_1dpi.var['MT']]
mt_genes

#let's just take a quick look at one of them.

mt_genes = adata_2dpi.var[adata_2dpi.var['MT']]
mt_genes

#let's just take a quick look at one of them.

mt_genes = adata_3dpi.var[adata_3dpi.var['MT']]
mt_genes

#calculate the qc metrics

sc.pp.calculate_qc_metrics(
    adata_mock, qc_vars=["MT", 'RIBO', 'HB'], inplace=True, log1p=True
)

#calculate the qc metrics

sc.pp.calculate_qc_metrics(
    adata_1dpi, qc_vars=["MT", 'RIBO', 'HB'], inplace=True, log1p=True
)

#calculate the qc metrics

sc.pp.calculate_qc_metrics(
    adata_2dpi, qc_vars=["MT", 'RIBO', 'HB'], inplace=True, log1p=True
)

#calculate the qc metrics

sc.pp.calculate_qc_metrics(
    adata_3dpi, qc_vars=["MT", 'RIBO', 'HB'], inplace=True, log1p=True
)

#note that it is also included in the headers of obs

adata_mock.obs.head()

adata_1dpi.obs.head()

adata_2dpi.obs.head()

adata_3dpi.obs.head()

#and your gene list
adata_mock.var.head()

adata_1dpi.var.head()

adata_2dpi.var.head()

adata_3dpi.var.head()

import matplotlib.pyplot as plt

plt.rcParams["figure.figsize"] = (5,4)  # Adjust figure size
plt.rcParams["axes.grid"] = True  # Add grid to plots
plt.rcParams["axes.edgecolor"] = "black" # Set plot border color
plt.rcParams["axes.linewidth"] = 1.5 # Set plot border width
plt.rcParams["axes.facecolor"] = "white" # Set background color
plt.rcParams["axes.labelcolor"] = "black" # Set label color
plt.rcParams["xtick.color"] = "black" # Set x-axis tick color
plt.rcParams["ytick.color"] = "black" # Set y-axis tick color
plt.rcParams["text.color"] = "black" # Set text color

sc.pl.violin(
    adata_mock,
    ["n_genes_by_counts", 'total_counts', 'pct_counts_MT'],
    jitter=0.4,
    multi_panel=False,
)

sc.pl.violin(
    adata_1dpi,
    ["n_genes_by_counts", 'total_counts', 'pct_counts_MT'],
    jitter=0.4,
    multi_panel=False,
)

sc.pl.violin(
    adata_2dpi,
    ["n_genes_by_counts", 'total_counts', 'pct_counts_MT'],
    jitter=0.4,
    multi_panel=False,
)

sc.pl.violin(
    adata_3dpi,
    ["n_genes_by_counts", 'total_counts', 'pct_counts_MT'],
    jitter=0.4,
    multi_panel=False,
)

sc.pl.scatter(adata_mock, "total_counts", "n_genes_by_counts", color="pct_counts_MT")

sc.pl.scatter(adata_1dpi, "total_counts", "n_genes_by_counts", color="pct_counts_MT")

sc.pl.scatter(adata_2dpi, "total_counts", "n_genes_by_counts", color="pct_counts_MT")

sc.pl.scatter(adata_3dpi, "total_counts", "n_genes_by_counts", color="pct_counts_MT")

#sc.pp.scrublet(adata_mock)

#sc.pp.scrublet(adata_1dpi)

#sc.pp.scrublet(adata_2dpi)

#sc.pp.scrublet(adata_3dpi)

#Normalisation
adata_mock.layers["counts"] = adata_mock.X.copy()
sc.pp.normalize_total(adata_mock)
sc.pp.log1p(adata_mock)

#Normalisation
adata_1dpi.layers["counts"] = adata_1dpi.X.copy()
sc.pp.normalize_total(adata_1dpi)
sc.pp.log1p(adata_1dpi)

#Normalisation
adata_2dpi.layers["counts"] = adata_2dpi.X.copy()
sc.pp.normalize_total(adata_2dpi)
sc.pp.log1p(adata_2dpi)

#Normalisation
adata_3dpi.layers["counts"] = adata_3dpi.X.copy()
sc.pp.normalize_total(adata_3dpi)
sc.pp.log1p(adata_3dpi)

#Feature selection
sc.pp.highly_variable_genes(adata_mock, n_top_genes=1000)
sc.pl.highly_variable_genes(adata_mock)

#Feature selection
sc.pp.highly_variable_genes(adata_1dpi, n_top_genes=1000)
sc.pl.highly_variable_genes(adata_1dpi)

#Feature selection
sc.pp.highly_variable_genes(adata_2dpi, n_top_genes=1000)
sc.pl.highly_variable_genes(adata_2dpi)

#Feature selection
sc.pp.highly_variable_genes(adata_3dpi, n_top_genes=1000)
sc.pl.highly_variable_genes(adata_3dpi)

#Dim Reduction
sc.tl.pca(adata_mock)

sc.pl.pca_variance_ratio(adata_mock, n_pcs=10, log=False)

#Dim Reduction
sc.tl.pca(adata_1dpi)

sc.pl.pca_variance_ratio(adata_1dpi, n_pcs=10, log=False)

#Dim Reduction
sc.tl.pca(adata_2dpi)

sc.pl.pca_variance_ratio(adata_2dpi, n_pcs=10, log=False)

#Dim Reduction
sc.tl.pca(adata_3dpi)

sc.pl.pca_variance_ratio(adata_3dpi, n_pcs=10, log=False)

adata_mock.obs['condition'] = 'mock'
sc.pl.pca(adata_mock, color="condition", cmap="coolwarm")

adata_1dpi.obs['condition'] = '1dpi'
sc.pl.pca(adata_1dpi, color="condition", cmap="coolwarm")

adata_2dpi.obs['condition'] = '2dpi'
sc.pl.pca(adata_2dpi, color="condition", cmap="coolwarm")

adata_3dpi.obs['condition'] = '3dpi'
sc.pl.pca(adata_3dpi, color="condition", cmap="coolwarm")

sc.pp.neighbors(adata_mock)
sc.tl.umap(adata_mock)

sc.pp.neighbors(adata_1dpi)
sc.tl.umap(adata_1dpi)

sc.pp.neighbors(adata_2dpi)
sc.tl.umap(adata_2dpi)

sc.pp.neighbors(adata_3dpi)
sc.tl.umap(adata_3dpi)

sc.pl.umap(
    adata_mock,
    color=["condition", 'ACE', 'ENO2'],
    size=10,
)

sc.pl.umap(
    adata_1dpi,
    color=["condition",'ACE2', 'ENO2'],
    size=10,
)

sc.pl.umap(
    adata_2dpi,
    color=["condition", 'ACE2', 'ENO2'],
    size=10,
)

sc.pl.umap(
    adata_3dpi,
    color=["condition", 'ACE2', 'ENO2'],
    size=10,
)

## Clustering by communities.

##Clustering by communities in single-cell RNA-seq is the process of grouping cells that show similar expression profiles â€” essentially, discovering putative cell types or states.

## Once PCA compresses your data into a manageable set of dimensions, clustering algorithms like Leiden operate on a graph-based representation of cellâ€“cell relationships.

## Usually used for cell type detection

# Using the igraph implementation and a fixed number of iterations can be significantly faster, especially for larger datasets
sc.tl.leiden(adata_mock, flavor="igraph", n_iterations=10, key_added="leiden_res_", resolution=0.25 )

# Using the igraph implementation and a fixed number of iterations can be significantly faster, especially for larger datasets
sc.tl.leiden(adata_1dpi, flavor="igraph", n_iterations=10, key_added="leiden_res_", resolution=0.25 )

# Using the igraph implementation and a fixed number of iterations can be significantly faster, especially for larger datasets
sc.tl.leiden(adata_2dpi, flavor="igraph", n_iterations=10, key_added="leiden_res_", resolution=0.25 )

# Using the igraph implementation and a fixed number of iterations can be significantly faster, especially for larger datasets
sc.tl.leiden(adata_3dpi, flavor="igraph", n_iterations=10, key_added="leiden_res_", resolution=0.25 )

sc.pl.umap(
    adata_mock,
    color=["leiden_res_"],
    size=10,
    title= 'mock'
)

sc.pl.umap(
    adata_1dpi,
    color=["leiden_res_"],
    size=10,
    title= '1dpi'
)

sc.pl.umap(
    adata_3dpi,
    color=["leiden_res_"],
    size=10,
    title= '3dpi'
)

sc.pl.umap(
    adata_2dpi,
    color=["leiden_res_"],
    size=10,
    title= '2dpi'
)

# Import decoupler for automatic mapping
import decoupler as dc

# Query Omnipath and get PanglaoDB
markers = dc.op.resource(name="PanglaoDB", organism="human")

markers.shape

markers.head()

markers['organ'].unique()

markers = markers[markers["organ"].isin(['Lungs', 'Epithelium', 'Immune system', 'Smooth Muscles'])]

markers.shape

import decoupler as dc
import pandas as pd

# 1. Re-load markers from the resource to ensure it's in the initial state
markers = dc.op.resource(name="PanglaoDB", organism="human")

# 2. Filter by organ
if 'organ' in markers.columns:
    markers = markers[markers["organ"].isin(['Lungs', 'Epithelium', 'Smooth muscle'])]
else:
    print("Warning: 'organ' column not found for organ filtering. Skipping.")

# 3. Remove duplicated entries using 'cell_type' and 'genesymbol'
# Check if columns exist before trying to use them for duplicated check
if 'cell_type' in markers.columns and 'genesymbol' in markers.columns:
    markers = markers[~markers.duplicated(["cell_type", "genesymbol"])]
else:
    print("Warning: 'cell_type' or 'genesymbol' column not found for duplicate removal. Skipping.")

# 4. Format because dc only accepts cell_type and genesymbol as 'source' and 'target'
# Check if columns exist before renaming
if 'cell_type' in markers.columns and 'genesymbol' in markers.columns:
    markers = markers.rename(columns={"cell_type": "source", "genesymbol": "target"})
else:
    print("Warning: 'cell_type' or 'genesymbol' column not found for renaming. Skipping.")

# 5. Select only 'source' and 'target' if they exist
if 'source' in markers.columns and 'target' in markers.columns:
    markers = markers[["source", "target"]]
else:
    print("Warning: 'source' or 'target' columns not found after processing. Final markers might be empty or incomplete.")

markers.head()

adata_mock.var_names
adata_2dpi.var_names
adata_2dpi.var_names
adata_3dpi.var_names

#mock
dc.mt.ulm(data=adata_mock, net=markers, tmin=3)

#1dpi
dc.mt.ulm(data=adata_1dpi, net=markers, tmin=3)

#2dpi
dc.mt.ulm(data=adata_2dpi, net=markers, tmin=3)

#3dpi
dc.mt.ulm(data=adata_3dpi, net=markers, tmin=3)

#mock
score_mock = dc.pp.get_obsm(adata_mock, key="score_ulm")

#1dpi
score_1 = dc.pp.get_obsm(adata_1dpi, key="score_ulm")

#2dpi
score_2 = dc.pp.get_obsm(adata_2dpi, key="score_ulm")

#3dpi
score_3 = dc.pp.get_obsm(adata_3dpi, key="score_ulm")

#Rank genes

#mock
adata_mock_gene_rank = dc.tl.rankby_group(score_mock, groupby="leiden_res0_02", reference="rest", method="t-test_overestim_var")
adata_mock_gene_rank = adata_mock_gene_rank[adata_mock_gene_rank["stat"] > 0]
adata_mock_gene_rank.head(5)

#1dpi
adata_1dpi_gene_rank = dc.tl.rankby_group(score_mock, groupby="leiden_res0_02", reference="rest", method="t-test_overestim_var")
adata_1dpi_gene_rank = adata_1dpi_gene_rank[adata_1dpi_gene_rank["stat"] > 0]
adata_1dpi_gene_rank.head(5)

#1dpi
adata_2dpi_gene_rank = dc.tl.rankby_group(score_mock, groupby="leiden_res0_02", reference="rest", method="t-test_overestim_var")
adata_2dpi_gene_rank = adata_2dpi_gene_rank[adata_2dpi_gene_rank["stat"] > 0]
adata_2dpi_gene_rank.head(5)

#1dpi
adata_3dpi_gene_rank = dc.tl.rankby_group(score_mock, groupby="leiden_res0_02", reference="rest", method="t-test_overestim_var")
adata_3dpi_gene_rank = adata_3dpi_gene_rank[adata_3dpi_gene_rank["stat"] > 0]
adata_3dpi_gene_rank.head(5)

#mock
top_cell_type_per_group_mock = adata_mock_gene_rank.groupby('group')['name'].apply(lambda x: x.head(1))
display(top_cell_type_per_group_mock.to_dict())

#1dpi
top_cell_type_per_group_1 = adata_1dpi_gene_rank.groupby('group')['name'].apply(lambda x: x.head(1))
display(top_cell_type_per_group_1.to_dict())

#2dpi
top_cell_type_per_group_2 = adata_2dpi_gene_rank.groupby('group')['name'].apply(lambda x: x.head(1))
display(top_cell_type_per_group_2.to_dict())

#3dpi
top_cell_type_per_group_3 = adata_3dpi_gene_rank.groupby('group')['name'].apply(lambda x: x.head(1))
display(top_cell_type_per_group_3.to_dict())

mock#
sc.pl.umap(score_mock, color=["Basal cells","leiden_res0_02"], cmap="coolwarm")

#1dpi
sc.pl.umap(score_1, color=["Basal cells","leiden_res0_02"], cmap="coolwarm")

#2dpi
sc.pl.umap(score_2, color=["Basal cells","leiden_res0_02"], cmap="coolwarm")

#3dpi
sc.pl.umap(score_3, color=["Basal cells","leiden_res0_02"], cmap="coolwarm")

sc.pl.umap(
    adata_mock,
    color=[ "leiden_res0_02", 'ENO2', 'ACE2'],
    ncols=8,
    title= 'mock'
)

sc.pl.umap(
    adata_1dpi,
    color=[ "leiden_res0_02", 'ENO2', 'ACE2'],
    ncols=8,
    title= '1dpi'
)

sc.pl.umap(
    adata_2dpi,
    color=[ "leiden_res0_02", 'ENO2', 'ACE2'],
    ncols=8,
    title= '2dpi'
)

sc.pl.umap(
    adata_3dpi,
    color=[ "leiden_res0_02", 'ENO2', 'ACE2'],
    ncols=8,
    title= '3dpi'
)

sc.pl.umap(
    adata_mock,
    color=[ "leiden_res0_02", 'YWHAH', 'SQSTM1', 'RPL37A', 'NFKBIZ', 'NFKBIA'],
    ncols=8,
    title= 'mock'
)

sc.pl.umap(
    adata_1dpi,
    color=[ "leiden_res0_02", 'YWHAH', 'SQSTM1', 'RPL37A', 'NFKBIZ', 'NFKBIA'],
    ncols=8,
    title= '1dpi'
)

sc.pl.umap(
    adata_2dpi,
    color=[ "leiden_res0_02", 'YWHAH', 'SQSTM1', 'RPL37A', 'NFKBIZ','NFKBIA' ],
    ncols=8,
    title= '2dpi'
)

sc.pl.umap(
    adata_3dpi,
    color=[ "leiden_res0_02", 'YWHAH', 'SQSTM1', 'RPL37A', 'NFKBIZ', 'NFKBIA'],
    ncols=8,
    title= '3dpi'
)

#mock
dict_ann_mock_raw = adata_mock_gene_rank[adata_mock_gene_rank["stat"] > 0].groupby("group").head().set_index("group")["name"].to_dict()
dict_ann_mock = {k: f"{v} ({k})" for k, v in dict_ann_mock_raw.items()}
display(dict_ann_mock)

#1dpi
dict_ann_1dpi_raw = adata_1dpi_gene_rank[adata_1dpi_adata_gene_rank["stat"] > 0].groupby("group").head().set_index("group")["name"].to_dict()
dict_ann_1dpi = {k: f"{v} ({k})" for k, v in dict_ann_1dpi_raw.items()}
display(dict_ann_1dpi)

#2dpi
dict_ann_2dpi_raw = adata_2dpi_gene_rank[adata_2dpi_gene_rank["stat"] > 0].groupby("group").head().set_index("group")["name"].to_dict()
dict_ann_2dpi = {k: f"{v} ({k})" for k, v in dict_ann_2dpi_raw.items()}
display(dict_ann_2dpi)

#3dpi
dict_ann_3dpi_raw = adata_3dpi_gene_rank[adata_3dpi_gene_rank["stat"] > 0].groupby("group").head().set_index("group")["name"].to_dict()
dict_ann_3dpi = {k: f"{v} ({k})" for k, v in dict_ann_3dpi_raw.items()}
display(dict_ann_3dpi)

#mock
adata_mock.obs["leiden_res0_02"] = adata_mock.obs["leiden_res0_02"].cat.rename_categories(dict_ann_mock)

#1dpi
adata_1dpi.obs["leiden_res0_02"] = adata_1dpi.obs["leiden_res0_02"].cat.rename_categories(dict_ann_1dpi)

#2dpi
adata_2dpi.obs["leiden_res0_02"] = adata_2dpi.obs["leiden_res0_02"].cat.rename_categories(dict_ann_2dpi)

#3dpi
adata_3dpi.obs["leiden_res0_02"] = adata_3dpi.obs["leiden_res0_02"].cat.rename_categories(dict_ann_3dpi)

print("Performing differential expression analysis for mock_adata...")
sc.tl.rank_genes_groups(adata_mock, groupby='leiden_res0_02', method='wilcoxon', rankby_abs=True, key_added='rank_genes_groups_mock')
print("Done with mock_adata.\nPerforming differential expression analysis for srv_1dpi_adata...")
sc.tl.rank_genes_groups(adata_1dpi, groupby='leiden_res0_02', method='wilcoxon', rankby_abs=True, key_added='rank_genes_groups_1dpi')
print("Done with srv_1dpi_adata.\nPerforming differential expression analysis for srv_2dpi_adata...")
sc.tl.rank_genes_groups(adata_2dpi, groupby='leiden_res0_02', method='wilcoxon', rankby_abs=True, key_added='rank_genes_groups_2dpi')
print("Done with srv_2dpi_adata.\nPerforming differential expression analysis for srv_3dpi_adata...")
sc.tl.rank_genes_groups(adata_3dpi, groupby='leiden_res0_02', method='wilcoxon', rankby_abs=True, key_added='rank_genes_groups_3dpi')
print("Done with srv_3dpi_adata.")

data_combined = ad.concat([adata_mock, adata_1dpi, adata_2dpi, adata_3dpi])

# Create a combined 'condition_cell_type' column for dot plot grouping
adata_combined.obs['condition_cell_type'] = adata_combined.obs['condition'].astype(str) + '_' + adata_combined.obs['leiden_res0_02'].astype(str)

print("Combined AnnData object created and 'condition_cell_type' column added.")
print(adata_combined.obs['condition_cell_type'].value_counts().head())

#Visualisation of cell annotation
# Leiden clustering identifies transcriptionally similar cell groups.
# This helps distinguish infected vs. bystander cell populations across infection stages.
#mock
sc.pl.umap(
    adata_mock,
    color=["leiden_res0_02"],
    ncols=3,
    title='Mock - Marker Gene Expression',
    size=5
)

#1dpi
sc.pl.umap(
    adata_1dpi,
    color=["leiden_res0_02"],
    ncols=3,
    title='1dpi - Marker Gene Expression',
    size=5
)

#2dpi
sc.pl.umap(
    adata_2dpi,
    color=["leiden_res0_02"],
    ncols=3,
    title='2dpi - Marker Gene Expression',
    size=5
)

#3dpi
sc.pl.umap(
    adata_3dpi,
    color=["leiden_res0_02"],
    ncols=3,
    title='3dpi - Marker Gene Expression',
    size=5
)

adata.obs['condition'].value_counts()

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Cell type frequency per condition
# Use 'leiden_res0_02' column which contains the annotated cell types
cell_counts = adata_combined.obs.groupby(['condition', 'leiden_res0_02']).size().reset_index(name='count')

sns.barplot(data=cell_counts, x='condition', y='count', hue='leiden_res0_02')
plt.title("Cell Type Distribution Across Infection Stages")
plt.ylabel("Number of Cells")
plt.xlabel("Condition")
plt.xticks(rotation=45)
plt.legend(title='Cell Type', bbox_to_anchor=(1,4), loc='upper left')
plt.tight_layout()
plt.show()

"""Trajectory Inference
It is an attempt to understand how cells transition from one type to another (like stem â†’ mature)?
"""

#Trajectory analysis
sc.tl.draw_graph(adata_mock)
sc.tl.draw_graph(adata_1dpi)
sc.tl.draw_graph(adata_2dpi)
sc.tl.draw_graph(adata_2dpi)

# mock
plt.rcParams["figure.figsize"] = (4,4)
sc.pl.draw_graph(adata_mock, color='leiden_res0_02', size = 16)

#1dpi
plt.rcParams["figure.figsize"] = (4,4)
sc.pl.draw_graph(adata_1dpi, color='leiden_res0_02', size = 16)

#2dpi
plt.rcParams["figure.figsize"] = (4,4)
sc.pl.draw_graph(adata_2dpi, color='leiden_res0_02', size = 16)

#3dpi
plt.rcParams["figure.figsize"] = (4,4)
sc.pl.draw_graph(adata_3dpi, color='leiden_res0_02', size = 16)

#PAGA mock to 3dpi

sc.tl.paga(adata_mock, groups='leiden_res0_02')
sc.tl.paga(adata_1dpi, groups='leiden_res0_02')
sc.tl.paga(adata_2dpi, groups='leiden_res0_02')
sc.tl.paga(adata_3dpi, groups='leiden_res0_02')

sc.pl.paga(adata_mock, color=['leiden_res0_02'])
sc.pl.paga(adata_1dpi, color=['leiden_res0_02'])
sc.pl.paga(adata_2dpi, color=['leiden_res0_02'])
sc.pl.paga(adata_3dpi, color=['leiden_res0_02'])

#mock
plt.rcParams["figure.figsize"] = (5,4)
sc.pl.paga_compare(adata_mock, threshold=0.03, frameon=True, edges=True, size = 16)

#1dpi
plt.rcParams["figure.figsize"] = (5,4)
sc.pl.paga_compare(adata_1dpi, threshold=0.03, frameon=True, edges=True, size = 16)

#2dpi
plt.rcParams["figure.figsize"] = (5,4)
sc.pl.paga_compare(adata_2dpi, threshold=0.03, frameon=True, edges=True, size = 16)

#3dpi
plt.rcParams["figure.figsize"] = (5,4)
sc.pl.paga_compare(adata_3dpi, threshold=0.03, frameon=True, edges=True, size = 16)

# Calculate diffusion pseudotime (DPT)

# mock
# As an example, let's select a cell from the first cluster (cluster '0') as the root.
# You might need to adjust this based on your biological knowledge.
root_cluster_mock = 'Ciliated cells (4)' # Corrected: based on dict_ann_mock, Ciliated cells is cluster 4
if root_cluster_mock in adata_mock.obs['leiden_res0_02'].cat.categories:
    root_cell_idx_mock = adata_mock.obs['leiden_res0_02'] == root_cluster_mock
    if np.any(root_cell_idx_mock):
        adata_mock.uns['iroot'] = np.flatnonzero(root_cell_idx_mock)[0] # Set iroot
        sc.tl.dpt(adata_mock) # Call dpt without the 'root' argument
    else:
        print(f"Warning: No cells found in cluster {root_cluster_mock} for mock_adata. Skipping DPT calculation.")
else:
    print(f"Warning: Cluster {root_cluster_mock} not found in mock_adata. Skipping DPT calculation.")

# 1dpi
root_cluster_1dpi = 'Myofibroblasts (0)' # Replace with the actual name of your root cluster if '0' is not correct
if root_cluster_1dpi in adata_1dpi.obs['leiden_res0_02'].cat.categories:
    root_cell_idx_1dpi = adata_1dpi.obs['leiden_res0_02'] == root_cluster_1dpi
    if np.any(root_cell_idx_1dpi):
        adata_1dpi.uns['iroot'] = np.flatnonzero(root_cell_idx_1dpi)[0] # Set iroot
        sc.tl.dpt(adata_1dpi) # Call dpt without the 'root' argument
    else:
        print(f"Warning: No cells found in cluster {root_cluster_1dpi} for srv_1dpi_adata. Skipping DPT calculation.")
else:
    print(f"Warning: Cluster {root_cluster_1dpi} not found in srv_1dpi_adata. Skipping DPT calculation.")

# 2dpi
root_cluster_2dpi = 'Mesothelial cells (0)' # Replace with the actual name of your root cluster if '0' is not correct
if root_cluster_2dpi in adata_2dpi.obs['leiden_res0_02'].cat.categories:
    root_cell_idx_2dpi = adata_2dpi.obs['leiden_res0_02'] == root_cluster_2dpi
    if np.any(root_cell_idx_2dpi):
        adata_2dpi.uns['iroot'] = np.flatnonzero(root_cell_idx_2dpi)[0] # Set iroot
        sc.tl.dpt(adata_2dpi) # Call dpt without the 'root' argument
    else:
        print(f"Warning: No cells found in cluster {root_cluster_2dpi} for srv_2dpi_adata. Skipping DPT calculation.")
else:
    print(f"Warning: Cluster {root_cluster_2dpi} not found in srv_2dpi_adata. Skipping DPT calculation.")

# 3dpi
root_cluster_3dpi = 'Airway goblet cells (0)' # Replace with the actual name of your root cluster if '0' is not correct
if root_cluster_3dpi in adata_3dpi.obs['leiden_res0_02'].cat.categories:
    root_cell_idx_3dpi = adata_3dpi.obs['leiden_res0_02'] == root_cluster_3dpi
    if np.any(root_cell_idx_3dpi):
        adata_3dpi.uns['iroot'] = np.flatnonzero(root_cell_idx_3dpi)[0] # Set iroot
        sc.tl.dpt(adata_3dpi) # Call dpt without the 'root' argument
    else:
        print(f"Warning: No cells found in cluster {root_cluster_3dpi} for srv_3dpi_adata. Skipping DPT calculation.")
else:
    print(f"Warning: Cluster {root_cluster_3dpi} not found in srv_3dpi_adata. Skipping DPT calculation.")

# Now plot with dpt_pseudotime
sc.pl.draw_graph(adata_mock, color=['dpt_pseudotime', 'leiden_res0_02'], legend_loc='on data', size = 24)
sc.pl.draw_graph(adata_1dpi, color=['dpt_pseudotime', 'leiden_res0_02'], legend_loc='on data', size = 24)
sc.pl.draw_graph(adata_2dpi, color=['dpt_pseudotime', 'leiden_res0_02'], legend_loc='on data', size = 24)
sc.pl.draw_graph(adata_3dpi, color=['dpt_pseudotime', 'leiden_res0_02'], legend_loc='on data', size = 24)

sc.pl.umap(adata_3dpi, color=['ACE2'], cmap='viridis')

# --- Statistical verification of ACE2 cluster enrichment (3 dpi) ---
import pandas as pd
import numpy as np
from scipy.stats import kruskal, mannwhitneyu, chi2_contingency
from statsmodels.stats.multitest import multipletests
import itertools
import seaborn as sns
import matplotlib.pyplot as plt

# --- Step 1: Extract ACE2 expression and cluster assignments ---
ace2_values = adata_3dpi[:, "ACE2"].X.toarray().flatten()
clusters = adata_3dpi.obs["leiden_res0_02"].values
df = pd.DataFrame({"cluster": clusters, "ACE2": ace2_values})

# --- Step 2: Global test (Kruskalâ€“Wallis) ---
groups = [df.loc[df['cluster'] == c, 'ACE2'].values for c in df['cluster'].unique()]
stat, p_value = kruskal(*groups)
print("ðŸ”¹ Kruskalâ€“Wallis test across clusters")
print(f"   H = {stat:.3f}, p = {p_value:.3e}")

# --- Step 3: Pairwise Mannâ€“Whitney U tests with FDR correction ---
pairs = list(itertools.combinations(df['cluster'].unique(), 2))
results = []
for c1, c2 in pairs:
    x = df.loc[df['cluster'] == c1, 'ACE2']
    y = df.loc[df['cluster'] == c2, 'ACE2']
    stat, p = mannwhitneyu(x, y, alternative='two-sided')
    results.append([c1, c2, stat, p])

results_df = pd.DataFrame(results, columns=['Cluster1', 'Cluster2', 'U_stat', 'p_value'])
results_df['p_adj'] = multipletests(results_df['p_value'], method='fdr_bh')[1]

# Print the most significant differences
print("\nðŸ”¹ Pairwise Mannâ€“Whitney tests (FDR-corrected)")
display(results_df.sort_values('p_adj').head(10))

# --- Step 4: Visualization ---
plt.figure(figsize=(10, 5))
sns.boxplot(x='cluster', y='ACE2', data=df, showfliers=False, palette='viridis')
sns.stripplot(x='cluster', y='ACE2', data=df, color='black', alpha=0.3, size=1)
plt.title("ACE2 Expression per Cluster (3 dpi)")
plt.ylabel("Normalized ACE2 Expression")
plt.xlabel("Leiden Cluster")
plt.show()

# --- Step 5: Optional Chi-square test for ACE2+ cell enrichment ---
df['ACE2_positive'] = df['ACE2'] > 0
contingency = pd.crosstab(df['cluster'], df['ACE2_positive'])
chi2, p_chi, dof, expected = chi2_contingency(contingency)
print("\nðŸ”¹ Chi-squared test for ACE2+ enrichment")
print(f"   Ï‡Â² = {chi2:.2f}, p = {p_chi:.3e}")

# --- Step 6: Interpret automatically ---
top_cluster = (
    df.groupby("cluster")["ACE2"].mean()
    .sort_values(ascending=False)
    .index[0]
)
print(f"\nâœ… Cluster {top_cluster} shows the highest mean ACE2 expression at 3 dpi.")

import numpy as np
from scipy.stats import wilcoxon
import seaborn as sns
import matplotlib.pyplot as plt

# Compare ACE2 expression across conditions
ace2_means = [adata_mock[:, 'ACE2'].X.mean(),
              adata_1dpi[:, 'ACE2'].X.mean(),
              adata_2dpi[:, 'ACE2'].X.mean(),
              adata_3dpi[:, 'ACE2'].X.mean()]

# Bootstrapped confidence intervals
boot_samples = 1000
ci_low, ci_high = np.percentile(
    [np.mean(np.random.choice(ace2_means, size=len(ace2_means), replace=True))
     for _ in range(boot_samples)],
    [2.5, 97.5]
)

print(f"95% CI for ACE2 mean expression: [{ci_low:.4f}, {ci_high:.4f}]")

sns.boxplot(data=[adata_mock[:, 'ACE2'].X.toarray().flatten(),
                 adata_1dpi[:, 'ACE2'].X.toarray().flatten(),
                adata_2dpi[:, 'ACE2'].X.toarray().flatten(),
                adata_3dpi[:, 'ACE2'].X.toarray().flatten()])
plt.xticks([0,1,2,3], ['mock','1dpi','2dpi','3dpi'])
plt.title("ACE2 Expression Across Conditions with 95% CI")
plt.show()